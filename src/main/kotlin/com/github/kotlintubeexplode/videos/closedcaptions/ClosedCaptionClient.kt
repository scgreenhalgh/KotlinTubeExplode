package com.github.kotlintubeexplode.videos.closedcaptions

import com.github.kotlintubeexplode.common.Language
import com.github.kotlintubeexplode.core.VideoId
import com.github.kotlintubeexplode.exceptions.KotlinTubeExplodeException
import com.github.kotlintubeexplode.internal.HttpController
import com.github.kotlintubeexplode.internal.VideoController
import com.github.kotlintubeexplode.internal.dto.ClosedCaptionTrackResponseDto
import java.io.File
import java.io.Writer
import kotlin.time.Duration

/**
 * Client for retrieving closed captions (subtitles) for YouTube videos.
 */
class ClosedCaptionClient internal constructor(
    private val httpController: HttpController,
    private val videoController: VideoController
) {
    /**
     * Gets the manifest that lists available closed caption tracks for the specified video.
     *
     * @param videoId The video ID
     * @return The closed caption manifest containing available tracks
     */
    suspend fun getManifest(videoId: VideoId): ClosedCaptionManifest {
        val playerResponse = videoController.getPlayerResponse(videoId)

        val tracks = playerResponse.captions?.playerCaptionsTracklistRenderer?.captionTracks
            ?.mapNotNull { track ->
                val url = track.baseUrl ?: return@mapNotNull null
                val languageCode = track.languageCode ?: return@mapNotNull null
                val languageName = track.name?.simpleText
                    ?: track.name?.runs?.firstOrNull()?.text
                    ?: languageCode

                ClosedCaptionTrackInfo(
                    url = url,
                    language = Language(languageCode, languageName),
                    isAutoGenerated = track.kind == "asr"
                )
            } ?: emptyList()

        return ClosedCaptionManifest(tracks)
    }

    /**
     * Gets the manifest that lists available closed caption tracks for the specified video.
     *
     * @param videoIdOrUrl The video URL or ID
     * @return The closed caption manifest containing available tracks
     */
    suspend fun getManifest(videoIdOrUrl: String): ClosedCaptionManifest {
        return getManifest(VideoId.parse(videoIdOrUrl))
    }

    /**
     * Gets the closed caption track identified by the specified track info.
     *
     * @param trackInfo The track metadata
     * @return The closed caption track containing all captions
     */
    suspend fun get(trackInfo: ClosedCaptionTrackInfo): ClosedCaptionTrack {
        // Enforce format=3 (XML format with word-level timing)
        val url = buildString {
            append(trackInfo.url)
            if (!trackInfo.url.contains("format=")) {
                append(if (trackInfo.url.contains("?")) "&" else "?")
                append("format=3")
            }
            if (!trackInfo.url.contains("fmt=")) {
                append("&fmt=3")
            }
        }

        val xml = httpController.get(url)
        val response = ClosedCaptionTrackResponseDto.parse(xml)

        val captions = response.captions.mapNotNull { captionData ->
            val text = captionData.text
            // Skip empty captions
            if (text.isNullOrEmpty()) return@mapNotNull null

            // Auto-generated captions may be missing offset or duration
            val offset = captionData.offset ?: return@mapNotNull null
            val duration = captionData.duration ?: return@mapNotNull null

            val parts = captionData.parts.mapNotNull { partData ->
                val partText = partData.text
                if (partText.isNullOrEmpty()) return@mapNotNull null
                ClosedCaptionPart(partText, partData.offset)
            }

            ClosedCaption(text, offset, duration, parts)
        }

        return ClosedCaptionTrack(captions)
    }

    /**
     * Writes the closed caption track to the specified writer in SRT format.
     *
     * @param trackInfo The track metadata
     * @param writer The writer to write to
     * @param onProgress Optional progress callback (0.0 to 1.0)
     */
    suspend fun writeToSrt(
        trackInfo: ClosedCaptionTrackInfo,
        writer: Writer,
        onProgress: ((Double) -> Unit)? = null
    ) {
        val track = get(trackInfo)

        track.captions.forEachIndexed { index, caption ->
            // Line number
            writer.write("${index + 1}\n")

            // Time start --> time end
            writer.write("${formatSrtTimestamp(caption.offset)} --> ${formatSrtTimestamp(caption.offset + caption.duration)}\n")

            // Content - escape the arrow sequence to avoid SRT parsing issues
            writer.write(caption.text.replace("-->", "––>"))
            writer.write("\n\n")

            onProgress?.invoke((index + 1.0) / track.captions.size)
        }
    }

    /**
     * Downloads the closed caption track to the specified file in SRT format.
     *
     * @param trackInfo The track metadata
     * @param filePath The path to write to
     * @param onProgress Optional progress callback (0.0 to 1.0)
     */
    suspend fun downloadSrt(
        trackInfo: ClosedCaptionTrackInfo,
        filePath: String,
        onProgress: ((Double) -> Unit)? = null
    ) {
        File(filePath).bufferedWriter().use { writer ->
            writeToSrt(trackInfo, writer, onProgress)
        }
    }

    /**
     * Gets the raw caption text as a plain string (no timing info).
     *
     * @param trackInfo The track metadata
     * @return All caption text joined together
     */
    suspend fun getAsText(trackInfo: ClosedCaptionTrackInfo): String {
        val track = get(trackInfo)
        return track.captions.joinToString(" ") { it.text }
    }

    private fun formatSrtTimestamp(duration: Duration): String {
        val totalMillis = duration.inWholeMilliseconds
        val hours = totalMillis / 3600000
        val minutes = (totalMillis % 3600000) / 60000
        val seconds = (totalMillis % 60000) / 1000
        val millis = totalMillis % 1000

        return "%02d:%02d:%02d,%03d".format(hours, minutes, seconds, millis)
    }
}
